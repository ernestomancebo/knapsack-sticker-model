\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[utf8]{inputenc}

\usepackage{geometry}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[backend=bibtex,style=verbose-trad2]{biblatex}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{multicol}

% \setlength{\parindent}{4em}
\setlength{\parskip}{1em}
\bibliography{citation-13218946.bib}

\title{Solucionando el problema de la mochila en el Modelo Sticker}
\author{Ernesto Mancebo}
\date{Febrero 2020}

% \tikzset{
%     pics/realline/.style 2 args = {
%         code = {
%             \draw [thick] (0,0) -- (6,0) node [right=2mm] {$$mathbb{R}};
%             \fill[black] (1,0) circle (1mm) node[abobe=2mm] {$#1$}
%                          (3,0) circle (1mm) node[abobe=2mm] {$#2$}
%                          (6,0) circle (1mm) node[abobe=2mm] {$V_4$};
%             \foreach \i [count=\j] in {0,0.5,1,1.5,3,4.5,6}
%                 \coordinate (-\j) at (i,0);
%         }
%     }
% }
\usepackage{tikz}
% \usetikzlibrary{positioning}

\tikzset{
  mynode/.style={fill,circle,inner sep=2pt,outer sep=0pt}
}


\begin{document}
    \maketitle
    \begin{abstract}
        Este documento tiene como objetivo la resolución de los problema \emph{suma de subconjuntos} y \emph{porblema de la mochila}, para éste último en sus versiones acotada y la no acotada, utilizando como apoyo para la resolución de ambos problemas las subrutinas \emph{ordenado por cardinalidad} y \emph{llenado en paralelo}.
    \end{abstract}

    \newpage
    \section{Introducción}
    \begin{tikzpicture}
        \draw[olive,thick,latex-latex] (0,0) -- (7,0)
        node[pos=0.25,mynode,fill=red,label=above:\textcolor{red}{A}]{}
        node[pos=0.5,mynode,fill=blue,text=blue,label=above:\textcolor{blue}{B}]{}
        node[pos=0.75,mynode,fill=green,text=green,label=above:\textcolor{green}{C}]{};

        \node at (3,0.3) {ho};
    \end{tikzpicture}

    \section{Modelo Sticker}
    El Modelo Sticker es un modelo de computación inpirado en cadenas de ADN propuesto por Sam Roweis \textcolor{red}{\cite{article}}, donde tal modelo se basa en procedimientos de filtrado, con memoria de acceso aleatorio y una nueva manera de codificar la información. En ese mismo orden, se distingue de otros modelos computacionales por la manera en que codifica la información.

    \subsection{Concepto de Cadena de Memoria}
    El eje central de este modelo son las cadenas de memoria, tales cadenas consisten en hebras simples de ADN del tipo $(n, k, m)$, tal que $n\geq k.m$, siendo $n$ la longitud de la cadena, $k$ las cantidad de subcadenas o regiones, y $m$ la longitud de cada subcadena.\textcolor{red}{ Las cadenas de memoria también se les conocen como moléculas y son representadas por sigma ($\sigma$)}. \par

    En ese mismo orden de ideas, un sticker es un elemento asociado a una región en la cadena de memoria, una vez asociado se dice que la región está complementada, transformando la cadena en una hebra doble parcial. En ese sentido, se dice que en cada región donde haya un sticker complementándole, esta región está \emph{activada}, mientras que la región donde se carezca de sticker se dice está \emph{desactivada}. Tal abstracción binaria también se puede expresar de modo \emph{0/1}.

    \subsection{Concepto de Tubo}
    Dentro del modelo sticker un tubo es un multiconjunto de complejos de memorias del mismo tipo.
    % Tal concepto se puede representar como una matriz de complejos de memoria del modo:
    %     $
    %     \left[
    %         \begin{array}{l}
    %             \sigma_0 \\
    %             \sigma_i \\
    %             \sigma_{i + 1} 
    %         \end{array}
    %     \right]
    %     $ \\
    Las operaciones a principales dentro de este modelo son:
    \begin{itemize}
        \item \emph{mezclar}$(T_1,T_2)$: Retorna la unión de los dos tubos devolviendo un solo tubo el cual contiene cada complejo de memoria proveniente de ambos tubos. También se nota como $(T_1\cup T_2)$.
        \item \emph{separar}$(T, i)$: Para un tubo $T$ y un índice $i$ tal que $(1 \leq i \leq n)$, retorna un $+(T, i)$ y $-(T, i)$, de modo que el primer tubo contiene todos los complejos de memoria cuya región $i$-ésima esté \emph{activada}, mientras que el segundo contiene los complejos cuya región $i$-ésima \emph{desactivada}.
        \item \emph{encender}$(T, i)$: Para un tubo $T$ y un índice $i$ tal que $(1 \leq i \leq n)$, retorna un tubo $T'$ con la región $i$-ésima \emph{activada} en cada complejo de memoria.
        \item \emph{apagar}$(T, i)$: Para un tubo $T$ y un índice $i$ tal que $(1 \leq i \leq n)$, retorna un tubo $T'$ con la región $i$-ésima \emph{desactivada} en cada complejo de memoria.
        \item \emph{leer}$(T)$: Dado un tubo $T\neq\emptyset$, lee su contenido.
    \end{itemize}
    \subsection{Concepto de Librería}
    Una librería dentro del modelo sticker consiste en complejos de memoria de modo $(k,l)$, teniendo $k$ sub cadenas y las primeras $l$ subcadenas están \emph{activadas} o \emph{desactivadas} en todas sus posibles combinaciones, mientras que las cadenas $k -l$ están \emph{desactivadas}.

    \section{Subrutina Ordenado por Cardinalidad}


    \textbf{Problema:} Sea $A = \{1,\cdots,p\}$, $B = \{b_1,\cdots,b_s\} \subseteq A$, $F = \{D_1,\cdots,D_t\} \subseteq P(A)$. Ordene los conjuntos de $F$ de acuerdo a su cardinalidad en $B$, o en otras palabras, la cantidad de elementos de $B\cap D_i$.


    El paper bajo estudio nos sugiere el implementar un programa molecular cuya entrada sea un tubo $T_0$ conteniendo complejos de memoría codificando cada conjunto de la familia $F$. Para esto, cada complejo de memoria en $T_0$ se representará mediante la función booleana  $T_0=\{\{\sigma:|\sigma|=p \land \exists j(\chi_{D_j}=\sigma)\}\}$; tal que $\chi_{D_j}$ es la función característica de $D_j$ en $A$, siendo $(\chi_{D_j}(i) = 1$ si $i \in D_j$ de lo contrario $\chi_{D_j} = 0$ si $i \in A - D_j)$.


    El programa a diseñar consistirá en un bucle principal realizando $s$ pasos, donde para el paso $i$-ésimo se tendrá $i+1$ tubos $(T_0, T_1,\cdots,T_i)$, tales tubos generados verificando la condición $\forall\sigma(\sigma\in T_j \rightarrow|\sigma\cap\{b_1,\cdots,b_i\}|=j)$.
    \subsection{Algoritmo}
    Las ideas previas nos indican el siguiente algoritmo: 
    \begin{algorithm}
        \begin{algorithmic}[1]
            \Procedure{$Cardinal\_Sort$}{$T_0,B$}
            \For { $i=1$ to $s$ }
            \State $(T_0, T'_0) \leftarrow separar(T_0, b_i)$
            \For { $j=0$ to $i-1$ }
            \State {$(T'_{j+1},T''_j) \leftarrow separar(T_j,b_i)$}
            \State {$T_j \leftarrow mezclar(T'_j,T''_j)$}
            \EndFor
            \State {$T_i \leftarrow T'_i$}
            \EndFor
            \State Return $T_0,...,T_s$
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    \newpage

    \subsection{Traza Subrutina Ordenado por Cardinalidad}
    A modo de ilustrar el comportamiendo y los conceptos empleados en el algoritmo concebido, tenemos:
    \begin{itemize}
        \item $A: \{0, 1, 2, 3, 4, 5, 6\}$
        \item $B: \{1, 2, 4\}$
        \item $F: \{\{2, 6\}, \{3\}, \{4\}, \{2, 4\}\}$
    \end{itemize}
    Identificando los elementos que cumplen $B\cap D_j$ en $F$ le resaltamos en rojo de modo que tenemos: $\{\{\textcolor{red}{2}, 6\}, \{3\}, \{\textcolor{red}{4}\}, \{\textcolor{red}{2, 4}\}\}$. Codificando $F$ para llevarlo a un tubo tendíamos: 


    $
        \begin{bmatrix}
            0 0 1 0 0 0 1 \\
            0 0 0 1 0 0 0 \\
            0 0 0 0 1 0 0 \\
            0 0 1 0 1 0 0 \\
        \end{bmatrix}
    $ 


Este $T_0$ codificando $F$ tras la ejecución de \emph{Cardinal\_Sort} tendremos: 

    $
    \begin{array}{l}
        T_0: [ 0 0 0 1 0 0 0 ] \\
        T_1: \left[ \begin{array}{l} 0 0 0 0 1 0 0 \\ 0 0 1 0 0 0 1 \end{array} \right] \\
        T_2: [0 0 1 0 1 0 0] \\
        T_3: [] \\
        T_4: [] \\
        T_5: [] \\
        T_6: [] 
    \end{array}
    $ 


Cumpliendo de esta manera la condición de $\forall\sigma(\sigma\in T_j \rightarrow|\sigma\in\{b_1,\cdots,b_i\}|=j)$.

    \subsection{Otras Notaciones}
    Para usos posteriores dentro de este informe, podemos notar el uso de \emph{Cardinal\_Sort} de modo:
    \begin{itemize}
        \item $Cardinal\_Sort(T_0)$ cuando $B=A$.
        \item $Cardinal\_Sort(T_0, l, k)$ cuando $B=\{l, l+1,\cdots,k\}$.
    \end{itemize}
    \newpage
    \section{Subrutina de Llenado}
    \textbf{Problema:} Sea $A=\{1,\cdots,p\}$,  $r \in \mathbb{N}$ y $f:A\rightarrow\mathbb{N}$ una función. Si $B\subseteq A$, notamos $f(B)=\sum_{i\in B}f(i)$, por conveniencia deifnimos que para $f(0)=0$. Sea $q_f=f(A)$, $A_i=\{0,\cdots,i\}$ $(0\leq i\leq p)$, y $T_0$ un multiconjunto de complejos de memoria de forma $(n,k,m)$ con $k\geq p+r+q_f$.


    Podemos decir que si $\sigma\in T_0$, podemos asumir que tal tubo está formado por las regiones:
    \begin{multicols}{2}
        \begin{itemize}
            \item $(A\sigma )=\sigma (1)\cdots\sigma (p)$
            \item $(L\sigma )=\sigma (p+1)\cdots\sigma (p+r)$
            \item $(F\sigma)=\sigma(p+r+1)\cdots\sigma(p+r+q_f)$
            \item $(R\sigma)=\sigma(p+r+q_f+1)\cdots$
        \end{itemize} 
    \end{multicols}


    La subrutina opera sobre $T_0$ modificando sus elemento haciendo las moléculas del tubo de salida en $(F_\sigma)$ el peso con respecto a $f$ del subconjunto en $A$ codificado en $(A_\sigma)$, siendo esto:

    \begin{multicols}{2}
        \begin{equation*}
            \sum_{i=1}^{p}\sigma(i)f(i)
            \sum_{j=p+r+1}^{p+r+q_f}\sigma(j)
        \end{equation*}
    \end{multicols}


    \subsection{Algoritmo}
    \begin{algorithm}
        \begin{algorithmic}[1]
            \Procedure{$Parallel\_Fill$}{$T_0,f,p,r$}
            \For { $i=1$ to $p$ }
                \State $(T^+_{i,0}, T^-_i) \leftarrow separar(T_{i-1}, i)$
                \For { $j=1$ to $f(i)$ }
                    \State {$T^+_{i,j} \leftarrow encender(T^+_{i,j},p+r+f(A_{i-1})+j)$}
                \EndFor
                \State {$T_i \leftarrow mezclar(T^+_{i,f(i)}, T^-_i)$}
            \EndFor
            \State Return $T_0$
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    Para cada $i (1\leq i \leq p)$ se consiredan las regiones: $R_i=\{p+r+f(A_{i-1})+1,\cdots,p+r+f(A_i)\}$.


   \subsection{\textcolor{red}{Traza Subrutina de Llenado}}
   Con tal de ilustrar la subrutina bajo estudio, utilicemos como entrada:
   \begin{itemize}
       \item $A: \{1, 2, 3, 4\}$
       \item $B: \{2, 3, 4\}$
       \item $T_0: \{\{2\}, \{4\}, \{3\}\}$
    \end{itemize}
    Una vez codificado el tubo $T_0$, tenemos:


$
    \begin{bmatrix}
    \textcolor{red}{0 1 0 0} 0 0 0 0 0 0 0 0 0 0 \\
    \textcolor{red}{0 0 0 1} 0 0 0 0 0 0 0 0 0 0 \\
    \textcolor{red}{0 0 1 0} 0 0 0 0 0 0 0 0 0 0
    \end{bmatrix}
$


Nótese que las primeras cuatro regiones resaltadas en rojo corresponden al tamaño $p$, reservado para codificar el valor de cada $B$. Una vez ilustrado el tubo $T_0$, una vez procesado por $Parallel\_Fill$, tendremos:


$
    \begin{bmatrix}
        \textcolor{red}{0, 1, 0, 0,} \textcolor{blue}{1, 1, 1, 0, 0, 0, 0, 0, 0, 0} \\
        \textcolor{red}{0, 0, 0, 1,} \textcolor{blue}{1, 1, 1, 1, 1, 1, 1, 1, 1, 1} \\
        \textcolor{red}{0, 0, 1, 0,} \textcolor{blue}{1, 1, 1, 1, 1, 1, 0, 0, 0, 0}
    \end{bmatrix}
$


    \section{Problema de Suma de Subconjuntos}
    \textbf{Problema:} Sea $A=\{1,\cdots,p\}$ y $\omega\rightarrow\mathbb{N}$ una función peso. Sea $k\in\mathbb{N}$, tal que $k\leq\omega(A)=q_\omega$, determinar si existe un subconjunto $B\subseteq A$, tal que la suma de los pesos en $B$ sea exactamente $k$.


    Definido una vez el problema, el paper bajo estudio presenta un diseño de un programa dentro del modelo sticker tal que resuelve el problema de la suma de subcojnuntos. El tubo de entrada $T_0$ conteniendo una librería de forma $p+q_\omega, q$. 


    La primera fase, la fase de llenado, cada molécula $\sigma$ del tubo de entrada \textcolor{red}{será llenado a fin de conseguir en los últimos componentes $q$ el peso de los subcojnuntos que codifica}.Los tubos objtenidos luego serán ordenados de acuerdo a su cardinalidad. Por último, el tubo $k$-ésimo es leído.

    El tubo obtenido del proceso descrito codifica los subconjuntos de $A$ para el peso $k$, en caso de existir.


    \subsection{Algoritmo}
    La descripción del planteamiento explicado sugiere un programa molecular como el que sigue:
    \begin{algorithm}
        \begin{algorithmic}[1]
            \Procedure{$Subset\_Sum$}{$p,w,k$}
            \State {$q_w \leftarrow \sum_{i=1}^{p}w(i)$}
            \State {$T_0 \leftarrow $ Libería$(p+q_w,p)$}
            \State {$T_1 \leftarrow Parallel\_Fill(T_0,w,p,0)$}
            \State {$T_salida \leftarrow Cardinal\_Sort(T_1,p+1,p+q_w)[k]$}
            \State{$leer(T_salida)$}
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}
    \subsection{\textcolor{red}{Traza}}
    Tomando como referencia el tubo $T_0$ del apartado anterior:


    $
        \begin{bmatrix}
            \textcolor{red}{0\,1\,0\,0,} \textcolor{blue}{1\,1\,1\,0\,0\,0\,0\,0\,0\,0} \\
            \textcolor{red}{0\,0\,0\,1,} \textcolor{blue}{1\,1\,1\,1\,1\,1\,1\,1\,1\,1} \\
            \textcolor{red}{0\,0\,1\,0,} \textcolor{blue}{1\,1\,1\,1\,1\,1\,0\,0\,0\,0}
        \end{bmatrix}
    $


    Para un $k=10$, una vez el $T_0$ sea procesado por $Subset\_Sum$ tendríamos como salida: $\textcolor{red}{0\,0\,0\,1\,} \textcolor{blue}{1\,1\,1\,1\,1\,1\,1\,1\,1\,1}$, pues si contamos los bits en la región azul nos da un total de $10$.

    \subsection{textcolor{red}{Diseño}}
    \section{Problema de la Mochila Acotado}
    \textbf{Problema:} sea $A=\{1,\cdots,p\}$ un conjunto finito no vacío, $\omega:A\rightarrow\mathbb{N}$ una función peso y $\rho:A\rightarrow\mathbb{N}$ una función valor. Sea $k, k'\in\mathbb{N}$ tal que $k\leq\omega(A)=q_\omega$ y $k'\leq\rho(A)=q_\rho$; determine si existe un subconjunto $B\subseteq A$ tal que $\omega(B)\leq k$ y $\rho(B)\geq k'$.


    Esto nos lleva plantear el diseño de un programa molecular el cual resuelva el problema propuesto empezando con una librería$(p+q_\omega+q_\rho, p)$.


    En la fase inicial, la fase de llenado, se procede como en el problema previo: cada complejo de memoria en el tubo inicial es llenado apropiadamente tal que codifique el \emph{peso} asociado al subconjunto, seguido de la ordenación de los mismos de acuerdo a su cardinalidad de $\omega(A\sigma)$, empezando por obtener algunos tubos $T_0,\cdots,T_{q_\omega}$ tales que $\forall\sigma(\sigma\in T_j \Rightarrow |\omega(A\sigma)|=j)$.


    Con los tubos $T_0\cup\cdots\cup T_k$ se lleva a cabo una segunda operación de llenado, esta con respecto a los \emph{valores}. Posteriormente, las moléculas $\sigma$ del tubo resultante son ordenadas con respecto a su cardinalidad en $\rho(A\sigma)$ , obteniendo nuevamente una serie de tubos de forma $T_0,\cdots,T_{q_\omega}$, tales que $\forall\sigma(\sigma\in T_j \Rightarrow |\rho(A\sigma)| = j)$.


    Finalmente, se obtiene la solución al problema con tubos $T_k'\cup\cdots T_{q_\rho}$ y estos son leidos.
    \newpage
    \subsection{Algoritmo}
    Las directrices del apartado anterior guían a definir un programa molecular de la siguiente forma

    \begin{algorithm}
        \begin{algorithmic}[1]
            \Procedure{$Bounded\_Knapsack$}{$p,w,\rho,k,k'$}
            \State {$q_w \leftarrow \sum_{i=1}^{p}w(i);\, q_\rho \leftarrow \sum_{i=1}^{p}\rho(i);\, T_0 \leftarrow $Libería$(p+q_w+q_\rho,p)$}
            \State {$T_0 \leftarrow Parallel\_Fill(T_0,w,p,0)$}
            \State {$T_0 \leftarrow Cardinal\_Sort(T_0,p+1,p+q_w)$}
            \State {$T_1 \leftarrow \emptyset$}
            \For {$i=1$ to $k$}
                \State {$T_1 \leftarrow mezclar(T_1,Cardinal\_Sort(T_0,p+1,p+q_w)[i])$}
            \EndFor
            \State {$T_0 \leftarrow Parallel\_Fill(T_1,\rho,p,q_w)$}
            \State {$Cardinal\_Sort(T_0,p+q_w+1,p+q_w,q_\rho)$}
            \State {$T_1 \leftarrow \emptyset$}
            \For {$i=k'$ to $q_\rho$}
                \State {$T_1 \leftarrow merge(T_1,Cardinal\_Sort(T_0,p+q_w + 1,p+q_w+q_\rho)[i])$}
            \EndFor
            \State{$leer(T_1)$}
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}
    \subsection{Diseño}
    \newpage
    \section{Problema de la Mochila No Acotado}
    \textbf{Problema:} bajo las mismas condiciones del problema anterior, determinar si un subconjunto $B\subseteq A$ tal que $\rho(B) =max\{\rho(C):C\subseteq A \land\omega(C) \leq k\}$.


    Una solución molecular es obtenida a partir del problema la mochila acotado, mas un cambio en la fase final donde se ordenan los tubos de salida con respecto a su valor y se elige sólamente el tubo con mayor valor.

    \subsection{Algoritmo}
    La nueva propuesta lleva a idear un programa molecular similar al previo mas se ha de notar las variaciones en la salida del programa al retornar sólo el tubo con mayor valor.
    \begin{algorithm}
        \begin{algorithmic}[1]
            \Procedure{$Unbounded\_Knapsack$}{$p,w,\rho,k,k'$}
            \State {$q_w \leftarrow \sum_{i=1}^{p}w(i);\,q_\rho \leftarrow \sum_{i=1}^{p}\rho(i);\, T_0 \leftarrow $Libería$(p+q_w+q_\rho,p)$}
            \State {$T_0 \leftarrow Parallel\_Fill(T_0,w,p,0)$}
            \State {$T_0 \leftarrow Cardinal\_Sort(T_0,p+1,p+q_w)$}
            \State {$T_1 \leftarrow \emptyset$}
            \For {$i=1$ to $k$}
            \State {$T_1  \leftarrow  mezclar(T_1,Cardinal\_Sort(T_0,p+1,p+q_w)[i])$}
            \EndFor
            \State {$T_0 \leftarrow Parallel\_Fill(T_1,\rho,p,q_w)$}
            \State {$i=q_\rho;t=0$}
            \While {$i \geq 1 \land t==0$}
                \State {$T' \leftarrow Cardinal\_Sort(T_0,p+q_w +1,p+q_w+q_\rho)[i]$}
                \If{$T'\neq\emptyset$}
                    \State{$leer(T')$}
                    \State{$t=1$}
                \Else
                    \State{$i=i-1$}
                \EndIf
            \EndWhile
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    \section{Conclusión}

    \section{Bibliografía}
    \newpage
    \printbibliography
\end{document}